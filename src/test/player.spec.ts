import * as assert from 'assert';
import { Anim } from '../core/types';
import { linear } from '../core/easings';
import { TestPlayer, animCtxtXYZ, logs, reset, TestPlayer2, incrementTick } from './fixtures';

describe("Player", () => {

    beforeEach(reset);

    async function anim1(a: Anim) {
        await a.animate({ target: "#x", top: [0, 100], duration: 100, easing: linear, release: -20 });
        a.animate({ target: "#y", left: [0, 100], duration: 100, easing: linear, release: -20 });
    }

    it("should provide the current time position", async function () {
        const p = new TestPlayer(animCtxtXYZ(), anim1);
        assert.equal(p.position, 0, "position 0");
        await p.move(80);
        assert.equal(p.position, 80, "position 80");
        await p.move(10);
        assert.equal(p.position, 10, "position 10");
        await p.move(0);
        assert.equal(p.position, 0, "position 0 (end)");
    });

    it("should provide the full animation duration() from start position", async function () {
        const p = new TestPlayer(animCtxtXYZ(), anim1);

        const d = await p.duration();
        assert.equal(d, 176, "duration");
        // assert.deepEqual(logs(), [], "DOM has not been updated");
        assert.equal(p.position, 0, "back to 0");
    });

    it("should provide the full animation duration() from any position", async function () {
        const p = new TestPlayer(animCtxtXYZ(), anim1);
        await p.move(48);
        reset();
        const d = await p.duration();
        assert.equal(d, 176, "duration");
        // assert.deepEqual(logs(), [], "DOM has not been updated");
        assert.equal(p.position, 48, "back to 48");
    });

    it("should provide duration with play statements", async function () {
        async function sample(a: Anim) {
            a.play({ alternate: true, times: 3, backSpeed: 3 }, a => {
                a.animate({ target: "#x", left: [0, 500], duration: 400, easing: linear });
            });
        }
        const p = new TestPlayer(animCtxtXYZ(), sample);
        const d = await p.duration();
        assert.equal(d, 1599, "duration"); // 1599 instead of 1600 because of rounding (as speed is 3)
    });

    it("should provide duration with play statements (2)", async function () {
        async function sample(a: Anim) {
            a.play({ alternate: true, times: 3, backSpeed: 3 }, a => {
                a.iterate(".colItem", (a, idx) => {
                    a.animate({ left: [0, 500], duration: 400, easing: linear, delay: idx * 40 });
                });
            });
        }
        const p = new TestPlayer(animCtxtXYZ(), sample);
        const d = await p.duration();
        assert.equal(d, 1920, "duration");
    });

    function anim2(a: Anim) {
        a.animate({ target: "#x", left: [0, 100], duration: 64, easing: linear });
    }

    function testRaf(cb: (time: number) => void) {
        setTimeout((t) => { incrementTick(); cb(t) }, 0);
    }

    it("should play fwd from the start to the end", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        assert.equal(p.position, 0, "start position");
        await p.play({ raf: testRaf });
        assert.equal(p.position, 64, " end position");

        assert.deepEqual(logs(), [
            '0: #x.left = 0px;',
            '1: #x.left = 25px;',
            '2: #x.left = 50px;',
            '3: #x.left = 75px;',
            '4: #x.left = 100px;'
        ], "logs");
    });

    it("should play backward from the end to the start", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.move(64);

        assert.equal(p.position, 64, "start position");
        await p.play({ raf: testRaf, forward: false });
        assert.equal(p.position, 0, "end position");

        assert.deepEqual(logs(), [
            '0: #x.left = 100px;', // this is generated by the direction change
            '0: #x.left = 75px;',  // move(64) will already have called left=100px, this is why we are here at step 0;
            '1: #x.left = 50px;',
            '2: #x.left = 25px;',
            '3: #x.left = 0px;'
        ], "logs");
    });

    it("should not play fwd when at end", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.move(64);
        reset();
        assert.equal(p.position, 64, "start position");
        await p.play({ raf: testRaf });
        assert.equal(p.position, 64, "start position");

        assert.deepEqual(logs(), [], "logs");
    });

    it("should not play backward when at end", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.play({ raf: testRaf, forward: false });
        assert.equal(p.position, 0, "end position");
        assert.deepEqual(logs(), ["0: #x.left = 0px;"], "logs"); // instruction generated by move(0)
    });

    it("should support onupdate as play argument", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2), traces: number[] = [];
        await p.play({
            raf: testRaf, onupdate: (timePos) => {
                traces.push(timePos)
            }
        });
        assert.deepEqual(traces, [0, 16, 32, 48, 64], "traces");
    });

    it("should support isPlaying", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        assert.equal(p.isPlaying, false, "not playing at start");
        const pp = p.play({ raf: testRaf });
        assert.equal(p.isPlaying, true, "p is playing");
        await pp;
        assert.equal(p.isPlaying, false, "not playing any more");
    });

    it("should support pause", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.play({
            raf: testRaf, onupdate: (timePos) => {
                if (timePos === 32) {
                    p.pause();
                }
            }
        });
        assert.equal(p.position, 32, "paused at 32");

        await p.play({ raf: testRaf });
        assert.equal(p.position, 64, "play restarted to the end");
    });

    it("should support stop", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        let sp;
        await p.play({
            raf: testRaf,
            onupdate: (timePos) => {
                if (timePos === 32) {
                    sp = p.stop();
                }
            }
        });
        await sp;
        assert.equal(p.position, 0, "position back to 0");
    });

    it("should automatically pause/restart when play is called inside a play call-stack", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        let pp;
        await p.play({
            raf: testRaf,
            onupdate: (timePos) => {
                if (timePos === 48) {
                    pp = p.play({ raf: testRaf, forward: false });
                }
            }
        });
        assert.equal(p.position !== 0, true, "initial play released before 2nd play completion");
        await pp;
        assert.deepEqual(logs(), [
            '0: #x.left = 0px;',
            '1: #x.left = 25px;',
            '2: #x.left = 50px;',
            '3: #x.left = 75px;', // 48ms
            '3: #x.left = 50px;',
            '5: #x.left = 25px;', // 4 is skipped due to test raf that doesn't behave as a normal raf (#4 corresponds to move 48+16 that was cancelled)
            '6: #x.left = 0px;'
        ], "logs");
    });

    it("should support speed", async function () {
        const p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.play({
            raf: testRaf,
            speed: 2
        });
        assert.deepEqual(logs(), [
            '0: #x.left = 0px;',
            '1: #x.left = 50px;',
            '2: #x.left = 100px;'
        ], "logs");

        await p.move(0);
        reset();
        await p.play({
            raf: testRaf,
            speed: 0.5
        });
        assert.deepEqual(logs(), [
            '0: #x.left = 12.5px;',
            '1: #x.left = 25px;',
            '2: #x.left = 37.5px;',
            '3: #x.left = 50px;',
            '4: #x.left = 62.5px;',
            '5: #x.left = 75px;',
            '6: #x.left = 87.5px;',
            '7: #x.left = 100px;'
        ], "logs");
    });

});
